# Engenharia de Software I

:desktop_computer: Curso ADS - FATEC de S√£o Jos√© dos Campos

Atividades da mat√©ria - Engenharia de Software I 



_______________________________________________________________________


:hatching_chick: 17/02/2023 (Sexta-feira)

Texto: 
"We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play.   On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth."

Atividade 1: O que √© engenharia de software? Qual a rela√ß√£o de engenharia de software com programa√ß√£o?

Coment√°rio: 
Este trecho destaca tr√™s diferen√ßas cr√≠ticas entre programa√ß√£o e engenharia de software: tempo, escala e trade-off. Essas diferen√ßas refletem a natureza complexa e desafiadora do trabalho de engenharia de software, em compara√ß√£o com o trabalho de programa√ß√£o.
Os engenheiros de software precisam estar mais preocupados com a passagem do tempo e a necessidade eventual de mudan√ßa. Isso ocorre porque o software √© um produto em constante evolu√ß√£o, que precisa se adaptar a mudan√ßas de acordo com as necessidades dos usu√°rios e as condi√ß√µes do mercado. Os engenheiros de software devem projetar e desenvolver sistemas que possam evoluir ao longo do tempo e que possam ser facilmente mantidos e atualizados.
Quanto √† escala, os engenheiros de software precisam estar mais preocupados com a efici√™ncia e a escalabilidade do software que produzem, bem como da organiza√ß√£o que est√° produzindo. Isso inclui a capacidade do software para lidar com grandes quantidades de dados e usu√°rios, bem como a capacidade da organiza√ß√£o para gerenciar grandes projetos de software com sucesso.
Por fim, os engenheiros de software s√£o frequentemente solicitados a tomar decis√µes mais complexas com resultados de alto risco, muitas vezes baseados em estimativas imprecisas de tempo e crescimento. Isso exige um conjunto de habilidades mais amplo e uma capacidade de gerenciamento de projetos mais sofisticada do que a programa√ß√£o simples.
Em resumo, o trabalho de engenharia de software √© mais complexo e desafiador do que a programa√ß√£o, exigindo uma abordagem mais sistem√°tica e estrat√©gica para o desenvolvimento de software. Os engenheiros de software precisam estar preocupados com o tempo, escala e tomada de decis√µes complexas, ao mesmo tempo que mant√©m um olho em como sua organiza√ß√£o est√° produzindo software eficientemente.

_______________________________________________________________________


:hatching_chick: 23/02/2023 (Quinta-feira)

Texto: 
"Within Google, we sometimes say, ‚ÄúSoftware engineering is programming integrated over time.‚Äù Programming  is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren‚Äôt squares, distance isn‚Äôt velocity. Software engineering isn‚Äôt programming."

Coment√°rio: 
Esse trecho destaca a ideia de que a engenharia de software √© mais do que apenas programa√ß√£o - √© programa√ß√£o integrada ao longo do tempo. Embora a programa√ß√£o seja uma parte importante da engenharia de software, a adi√ß√£o da dimens√£o do tempo torna a engenharia de software uma disciplina distinta e mais ampla do que apenas a programa√ß√£o.
A distin√ß√£o entre tarefas de programa√ß√£o e tarefas de engenharia de software √© importante porque as tarefas de engenharia de software envolvem n√£o apenas o desenvolvimento de novos softwares, mas tamb√©m sua modifica√ß√£o e manuten√ß√£o ao longo do tempo. Isso inclui n√£o apenas a escrita de c√≥digo, mas tamb√©m atividades como an√°lise de requisitos, design de sistemas, gerenciamento de projetos, testes e garantia de qualidade.
Al√©m disso, a engenharia de software √© uma disciplina que aborda problemas complexos em sistemas de software em grande escala, e leva em considera√ß√£o os aspectos de tempo, efici√™ncia, escalabilidade, seguran√ßa, confiabilidade e outros aspectos relevantes. Esses aspectos v√£o al√©m da programa√ß√£o em si e exigem uma abordagem mais sistem√°tica e estrat√©gica para o desenvolvimento e manuten√ß√£o de software.
Em resumo, a engenharia de software √© uma disciplina distinta que envolve muito mais do que apenas programa√ß√£o. Ela aborda problemas complexos em sistemas de software em grande escala e leva em considera√ß√£o os aspectos de tempo, efici√™ncia, escalabilidade, seguran√ßa, confiabilidade e outros aspectos relevantes.

_______________________________________________________________________


:hatching_chick: 24/02/2023 (Sexta-feira)

Atividade 2: O que s√£o requisitos? Requisitos funcionais? Requisitos n√£o funcionais?

Requisitos s√£o as necessidades e expectativas dos stakeholders (partes interessadas) de um sistema de software. Eles descrevem o que o sistema deve fazer ou como ele deve funcionar e s√£o fundamentais para o desenvolvimento bem-sucedido de um software.
Os requisitos funcionais s√£o os requisitos que descrevem as funcionalidades que o sistema deve fornecer para atender √†s necessidades do usu√°rio. Eles geralmente incluem descri√ß√µes de tarefas que o sistema deve executar, dados que o sistema deve armazenar e manipular, e como o usu√°rio deve interagir com o sistema. Os requisitos funcionais s√£o frequentemente escritos em linguagem natural, como descri√ß√µes de casos de uso ou hist√≥rias de usu√°rio.
Os requisitos n√£o funcionais s√£o os requisitos que descrevem as caracter√≠sticas e propriedades do sistema que n√£o est√£o diretamente relacionadas √†s funcionalidades que o sistema deve fornecer. Eles geralmente incluem requisitos de desempenho, confiabilidade, seguran√ßa, usabilidade, escalabilidade, manutenibilidade, entre outros aspectos. Os requisitos n√£o funcionais s√£o importantes para garantir que o sistema atenda aos padr√µes de qualidade e efici√™ncia esperados pelos stakeholders.


Atividade 3: Escreva 2 exemplos de trade-offs envolvendo requisitos n√£o funcionais?

Os trade-offs envolvendo requisitos n√£o funcionais s√£o decis√µes dif√≠ceis que os engenheiros de software precisam tomar para balancear v√°rios requisitos n√£o funcionais e atender aos objetivos do projeto. Abaixo est√£o dois exemplos comuns de trade-offs envolvendo requisitos n√£o funcionais:

Seguran√ßa vs. Usabilidade:
Um exemplo de trade-off entre requisitos n√£o funcionais √© entre seguran√ßa e usabilidade. Um sistema extremamente seguro pode ser dif√≠cil de usar, pois muitas vezes exige v√°rias etapas de autentica√ß√£o e verifica√ß√µes de seguran√ßa, o que pode diminuir a experi√™ncia do usu√°rio. Por outro lado, um sistema muito f√°cil de usar pode ser menos seguro, pois as medidas de seguran√ßa podem ser simplificadas ou reduzidas para facilitar o acesso. Nesse caso, os engenheiros de software precisam decidir qual √© a melhor abordagem para balancear a seguran√ßa e usabilidade do sistema, levando em considera√ß√£o as necessidades dos usu√°rios e as exig√™ncias de seguran√ßa.

Desempenho vs. Escalabilidade:
Outro exemplo de trade-off entre requisitos n√£o funcionais √© entre desempenho e escalabilidade. Um sistema com alto desempenho pode ser otimizado para executar tarefas rapidamente, mas pode ter dificuldade em lidar com muitos usu√°rios simultaneamente, o que pode afetar sua escalabilidade. Por outro lado, um sistema escal√°vel pode ser projetado para lidar com grandes quantidades de usu√°rios, mas pode ter um desempenho mais lento em tarefas espec√≠ficas. Nesse caso, os engenheiros de software precisam decidir qual √© a melhor abordagem para balancear o desempenho e escalabilidade do sistema, levando em considera√ß√£o as necessidades dos usu√°rios e as exig√™ncias de neg√≥cios.

_______________________________________________________________________


:hatching_chick: 17/03/2023 (Sexta-feira)

Olhar no teams, no slide 23, um v√≠deo: 
https://docs.google.com/presentation/d/1GMds68vXowb3h_GFtI3fwKeXJQQJjm7L-wL0BJhIfLI/edit#slide=id.p3

Fazer um Diagrama de Classes UML seguindo o exemplo apresentado pelo professor em sala de aula.



<img src="/img/20230317_Diagrama_Classe_UML.jpeg" alt="Diagrama de Classes UML" width="200">



_______________________________________________________________________


:hatching_chick: 24/03/2023 (Sexta-feira)

Fazer o c√≥digo do Diagrama de Classes UML descrito acima.</br>
üîñ C√≥digo se encontra no ([Link da Pasta](https://github.com/ClaudiaCBS/ADS02_IES100/tree/main/Hospital)).







